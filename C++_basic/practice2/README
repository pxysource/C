         第二部分 ∙ 知识点：面向对象编程（上）

【2.1】设计一个类（Kitty），用来表征小猫咪。假定每只小猫在创建时都有固定的毛色和
性别，体重会随着吃而逐渐增加。
（类与对象、构造函数、成员权限限定）
    成员数据包括：
        体重（weight）
        性别（gender）
        毛色（color）
    成员方法包括：
        吃（eat）
        睡（sleep）
        卖萌（actingCute）
        查看身体各项指标（info）

【2.2】设计一个类（Student），用来表征一个学生。在初始化一个学生对象时必须提供
姓名和学号，并且一旦确定无法修改。
（const成员数据、静态成员、特殊成员初始化、构造函数初始化列表）
    成员数据包括：
        学号（ID），一旦确定无法修改
        姓名（name），一旦确定无法修改
        成绩（score）
    成员方法包括：
        构造函数
        获取学号
        获取姓名
        设置和获取成绩
        求所有学生对象的平均分

【2.3】分析以下代码的执行结果：
（类继承关系中构造函数、析构函数执行次序）
    class Base
    {
    public:
       Base() {cout << “B” << endl;}
      ~Base(){cout << “~B” << endl;}
    };
    
    class Derived : public Base
    {
     public:
      Derived() {cout << “D” << endl;}
      ~Derived(){cout << “~D” << endl;}
    };
     
    int main(void)
    {
      Derive d;
    }

【2.4】设计一个（Car）类，用来表征一辆汽车，令其包含如下成员：
    成员数据包括：
        质量（mass）
        最高速度（maxSpeed）
    成员方法包括：
        行驶（move）
        维修（maintain）

        以 Car 为基类，设计若干派生类，比如电动汽车（ElectroMobile）、飞行汽车
（AeroCar）、房车（MotorHomes）等。为特定种类的派生类增加新的成员，来表达其
新的属性和行为，比如电动汽车有电量（electricQuantity）属性，可以充电（charge）；
飞行汽车可以飞；房车有床位（beds）、卫星电话（satellitePhone），可以宿营
（camping）、烹饪（cooking）等。
（类继承，普通基类、派生类、is-a关系、基类构造函数的调用）

【2.5】设计一个基类（Shape），表达几何形状，并由它派生出圆（Circle）、矩形
（Rectangle）两个子类。
（抽象基类、纯虚函数）
    基类包含成员数据：
        位置坐标（x, y）
    基类包含成员方法：
        求面积（area）
        求周长（perimeter）
        显示相关信息（info）（比如图形的位置、圆的半径、矩形的边长等）

【2.6】设计一个基类（airCraft），表达飞行器，并由它派生出直升机（Copter）和轰炸
机（Bomber）两个子类。
（抽象基类、纯虚函数、普通虚函数）
    基类包含成员数据：
        无
    基类包含成员方法：
        加油（refuel）
        飞行（fly）

假定：
    不同的飞行器可以加充通用航空燃油，同时允许特定飞行器加充适合其机型的特定燃油；
    不同的飞行器没有通用的飞行方式，每一种特定的飞行器必须定义其特定的飞行方式。

【2.7】在上一题（2.6）的基础上，设计一个飞行员类（Pilot），该类对象可以为飞行器加
充燃油，也可以驾驶指定的飞行器，要求只要给飞行员一架飞机，他就能以适应这架飞机机
型的方式去加油和飞行。
（虚函数、多态）

【2.8】简述构造函数、析构函数和虚函数的关系。

【2.9】派生类从基类那里继承了什么？ 什么东西是派生类无法从基类那里继承的？

【2.10】由数学定义可知，线段由两个端点确定。设计一个 Line 类，并将 Point 类对象作
为其数据成员，实现对 Line 的定义，并提供获取线段长度的接口。
（类对象成员、has-a关系、对象初始化列表）

【2.11】分析以下代码的执行结果：
（对象包含关系中构造函数、析构函数执行次序）
1 class Part1
2 {
3 public:
4  Part1(){cout << "P1" << endl;}
5  ~Part1(){cout << "~P1" << endl;}
6 };
7
8 class Part2
9 {
10 public:
11  Part2(){cout << "P2" << endl;}
12  ~Part2(){cout << "~P2" << endl;}
13 };
14
15 class Whole
16 {
17  Part1 p1;
18  Part2 p2;
19 public:
20  Whole(){cout << "W" << endl;}
21  ~Whole(){cout << "~W" << endl;}
22 };
23
24 int main(int argc, char **argv)
25 {
26  Whole w;
27  return 0;
28 }
